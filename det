import cv2
import torch
from yolov5.models.experimental import attempt_load
from yolov5.utils.general import non_max_suppression, scale_coords
from yolov5.utils.torch_utils import select_device

# Load your YOLOv9-c model
model_path = 'yolov9-c.pt'
device = select_device('0' if torch.cuda.is_available() else 'cpu')  # Select device (0 for GPU, 'cpu' for CPU)
model = attempt_load(model_path, map_location=device)  # Load model

import nanocamera as nano

camera = nano.Camera(flip=2, width=640, height=480, fps=30)
print('CSI Camera Ready: ', camera.isReady())

def process_frame(frame, model, device):
    # Preprocess the frame for YOLO
    img = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    img = img / 255.0  # Normalize to 0-1
    img = torch.from_numpy(img).to(device).float()
    img = img.permute(2, 0, 1).unsqueeze(0)  # Reshape for model (1, 3, 640, 480)

    # Perform inference
    pred = model(img, augment=False)[0]
    pred = non_max_suppression(pred, 0.4, 0.5)  # Apply NMS

    # Process detections
    for det in pred:
        if len(det):
            # Rescale boxes from img size to original frame size
            det[:, :4] = scale_coords(img.shape[2:], det[:, :4], frame.shape).round()

            # Draw boxes and labels on the frame
            for *xyxy, conf, cls in det:
                label = f'{model.names[int(cls)]} {conf:.2f}'
                cv2.rectangle(frame, (int(xyxy[0]), int(xyxy[1])), (int(xyxy[2]), int(xyxy[3])), (255, 0, 0), 2)
                cv2.putText(frame, label, (int(xyxy[0]), int(xyxy[1]) - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)
    
    return frame

while camera.isReady():
    try:
        frame = camera.read()
        frame = process_frame(frame, model, device)
        cv2.imshow("video frame", frame)
        if cv2.waitKey(25) & 0xFF == ord('q'):
            break
    except KeyboardInterrupt:
        break

camera.release()
del camera
cv2.destroyAllWindows()